{-# LANGUAGE RecordWildCards, NamedFieldPuns, TypeApplications #-}

module SuperfluousBracketsSpec (spec) where

import Test.QuickCheck (Gen, forAll, choose, suchThat, (==>))
import Data.Either.Extra (fromRight')
import Data.List.Extra (notNull)
import Test.Hspec (Spec, describe, it)
import Text.Parsec (parse)

import Tasks.SuperfluousBrackets.Quiz (generateSuperfluousBracketsInst)
import Tasks.SuperfluousBrackets.Config(
  SuperfluousBracketsConfig(..),
  SuperfluousBracketsInst(..),
  checkSuperfluousBracketsConfig,
  defaultSuperfluousBracketsConfig)
import Tasks.SynTree.Config (SynTreeConfig(..))
import SynTreeSpec (validBoundsSynTree)
import Trees.Types (SynTree(..), BinOp(..), PropFormula)
import Trees.Helpers (numberAllBinaryNodes, sameAssociativeOperatorAdjacent, treeNodes)
import Trees.Print (display, simplestDisplay)
import Tasks.SuperfluousBrackets.PrintSuperfluousBrackets (
  superfluousBracketsDisplay,
  sameAssociativeOperatorAdjacentSerial
  )
import Trees.Parsing(formulaParse)
import TestHelpers (deleteBrackets)
import Trees.Generate (genSynTree)
import Formula.Parsing (Parse(parser))
import Control.Monad.Output (LangM)
import Data.Maybe (isJust)
import Control.Monad.Identity (Identity(runIdentity))
import Control.Monad.Output.Generic (evalLangM)

validBoundsSuperfluousBrackets :: Gen SuperfluousBracketsConfig
validBoundsSuperfluousBrackets = do
    syntaxTreeConfig@SynTreeConfig {..} <- validBoundsSynTree `suchThat` \SynTreeConfig{..} -> 2 * minUniqueBinOperators + 2 < minNodes
    superfluousBracketPairs <- choose (1, minNodes `div` 2)
    return $ SuperfluousBracketsConfig
        {
          syntaxTreeConfig
        , superfluousBracketPairs
        , extraText = Nothing
        , printSolution = False
        }

spec :: Spec
spec = do
    describe "config" $ do
      it "default config should pass config check" $
        isJust $ runIdentity $ evalLangM (checkSuperfluousBracketsConfig defaultSuperfluousBracketsConfig :: LangM Maybe)
      it "validBoundsSuperfluousBrackets should generate a valid config" $
        forAll validBoundsSuperfluousBrackets $ \superfluousBracketsConfig ->
          isJust $ runIdentity $ evalLangM (checkSuperfluousBracketsConfig superfluousBracketsConfig :: LangM Maybe)
    describe "sameAssociativeOperatorAdjacent" $ do
        it "should return false if there are no two \\/s or two /\\s as neighbors" $
            not $ sameAssociativeOperatorAdjacent (Binary Or (Leaf 'a') (Not (Binary Or (Leaf 'a') (Leaf 'c'))))
        it "should return true if two \\/s or two /\\s are Neighboring " $
            sameAssociativeOperatorAdjacent $
              Not $ Binary And (Binary Equi (Leaf 'a') (Leaf 'b')) (Binary And (Leaf 'a') (Leaf 'c'))
    describe "sameAssociativeOperatorAdjacent... functions" $
        it "is a consistent pair of functions" $
            forAll validBoundsSuperfluousBrackets $
              \SuperfluousBracketsConfig {..} ->
                forAll
                  (genSynTree syntaxTreeConfig) $ \synTree ->
                    sameAssociativeOperatorAdjacent synTree ==>
                      notNull (sameAssociativeOperatorAdjacentSerial (numberAllBinaryNodes synTree) Nothing)
    describe "simplestDisplay and superfluousBracketsDisplay" $ do
        it "simplestDisplay should have less brackets than or equal to normal formula" $
            forAll validBoundsSuperfluousBrackets $
              \SuperfluousBracketsConfig {..} ->
                forAll
                  (genSynTree syntaxTreeConfig) $ \synTree ->
                    length (sameAssociativeOperatorAdjacentSerial (numberAllBinaryNodes synTree) Nothing) *2
                      == length (display synTree) - length (simplestDisplay synTree)
        it
          ( "the number of brackets generated by simplestDisplay and display should be equal " ++
            "if 'sameAssociativeOperatorAdjacent' is not satisfied."
          ) $
            forAll (validBoundsSuperfluousBrackets `suchThat` \cfg -> maxDepth (syntaxTreeConfig cfg) < 6) $
              \SuperfluousBracketsConfig {..} ->
                forAll
                (genSynTree syntaxTreeConfig) $
                  \synTree -> not (sameAssociativeOperatorAdjacent synTree) ==>
                    display synTree == simplestDisplay synTree
        it "after remove all bracket two strings should be same" $
            forAll validBoundsSuperfluousBrackets $ \config ->
                forAll (generateSuperfluousBracketsInst config) $ \SuperfluousBracketsInst{..} ->
                  deleteBrackets stringWithSuperfluousBrackets == deleteBrackets simplestString
    describe "valid formula" $
        it "the formula Parser can accept when brackets is max number" $
            forAll validBoundsSuperfluousBrackets $
              \SuperfluousBracketsConfig {..} ->
                forAll
                    (genSynTree syntaxTreeConfig
                      `suchThat` sameAssociativeOperatorAdjacent
                    ) $
                      \synTree -> forAll (superfluousBracketsDisplay synTree (treeNodes synTree + 1)) $
                        \stringWithSuperfluousBrackets ->
                          formulaParse stringWithSuperfluousBrackets == Right synTree
    describe "generateSuperfluousBracketsInst" $ do
        it "show and parse are inverse for parsePropForm (?)" $
            forAll validBoundsSuperfluousBrackets $ \config ->
                forAll (generateSuperfluousBracketsInst config) $ \SuperfluousBracketsInst{..} ->
                  show (fromRight' (parse (parser @(PropFormula Char)) "" simplestString)) == simplestString
        it "the stringWithSuperfluousBrackets should have right number of SuperfluousBrackets" $
            forAll validBoundsSuperfluousBrackets $ \config@SuperfluousBracketsConfig {..} ->
                forAll (generateSuperfluousBracketsInst config) $ \SuperfluousBracketsInst{..} ->
                  fromIntegral (length stringWithSuperfluousBrackets - length simplestString)
                    == superfluousBracketPairs * 2
