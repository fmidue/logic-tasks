{-# language DeriveDataTypeable#-}

module Global where


import Control.OutputCapable.Blocks
import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..), PropFormula(..))
import Data.Text (Text, pack)
import Data.Data (Data)


newtype Table = Table [(Maybe (PropFormula Char), [Maybe TruthValue])] deriving (Eq,Show)

data Namen = A | B | C deriving (Eq,Enum,Bounded,Show,Ord,Data)
allNamen :: [Namen]
allNamen = [A,B,C]

type Submission = (PropFormula Char,PropFormula Char,PropFormula Char,PropFormula Char,Table,[Namen])
type TaskData = ([Text],([Bool],[SynTree BinOp Char]))


emptyColumns, staticColumns, staticColsEnd, totalColumns, rows :: Int
emptyColumns  = 4
staticColumns = 3
staticColsEnd = 1
totalColumns  = staticColumns + emptyColumns + staticColsEnd
rows          = 2^staticColumns

showSolution :: Bool
showSolution  = True



bothLangs :: OutputCapable m => String -> LangM m
bothLangs s = translate $ german s >> english s

=============================================

{-# language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# language QuasiQuotes #-}
{-# language RecordWildCards #-}
{-# language TupleSections #-}

module TaskData (getTask) where


import Data.Char               (digitToInt)
import Data.List               (transpose, sortOn)
import Data.String             (fromString)
import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.FormUtil (
  ($$>),
  addCss,
  getFormData,
  )
import FlexTask.Generic.Form (
  Alignment(..),
  Formify(..),
  formify,
  formifyInstanceMultiChoice,
  single,
  buttonsEnum
  )
import FlexTask.Types          (HtmlDict)
import FindLiarTask
import LogicTasks.Forms        (tableForm)
import LogicTasks.Formula      (TruthValue(..))
import Numeric                 (showBin)
import Test.QuickCheck.Gen
import Yesod

import Trees.Types (BinOp(..), SynTree(..))

import Global




instance MonadFail Gen where
  fail = error


getTask :: Gen (TaskData, String, IO ([Text], HtmlDict))
getTask = do
    d@(x, y, z, _) <- taskData
    let (formulas, hints) = makeHintsAndFormula d

        dataSortedOnName = sortOn fst [x, y, z]
        (formulasSorted, hintsSorted) = unzip $ sortOn snd $ zip formulas hints

        solutionValues = map snd dataSortedOnName

    pure ((hintsSorted, (solutionValues, formulasSorted)),
          checkers,
          getFormData form)
  where
    form = formify (Nothing :: Maybe (String, String, String))
             [[single "1) "],
             [single "2) "],
             [single "3) "]] $$>
           formify (Nothing :: Maybe String)
             [[single "Gesamtformel F="]] $$>
           addCss formulaCss (tableForm emptyColumns rows ["A","B","C"] ["F"]) $$>
           formify (Nothing :: Maybe [Namen])
             [[buttonsEnum Vertical "Wer lügt?" (fromString . show @Namen)]]

    fromChar 'A' = A
    fromChar 'B' = B
    fromChar 'C' = C
    fromChar  _  = error "invalid Name"


    formulaCss = [cassius|
       th, td
        border: 1px solid black
        border-collapse: collapse
        text-align: center
      table tr th:nth-child(-n+3)
        width: 20px
      table tr td:nth-child(-n+3)
        height: 25px
      table tr th:nth-child(n+4)
        width: 125px
      table tr th:nth-child(n+8)
        width: 25px
      table tr th:last-child
        padding: 10px 0px
       |]



instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



startingTable :: [[Maybe TruthValue]]
startingTable = map (Just . TruthValue . toEnum . digitToInt) <$>
    transpose (pad . (`showBin` "") <$> [0..rows -1])
  where pad s = replicate (staticColumns - length s) '0' ++ s



checkers :: String
checkers = [i|

{-\# language ApplicativeDo \#-}
{-\# language OverloadedStrings \#-}
{-\# language TypeApplications \#-}


module Check (checkSemantics, checkSyntax) where

import Control.Monad (when)
import Control.OutputCapable.Blocks
import Data.Containers.ListUtils (nubOrd)
import Data.List     (transpose)
import Data.Ratio    ((%))


import LogicTasks.Formula (TruthValue(..), isSemanticEqual)
import Trees.Print (simplestDisplay)
import Trees.Types (SynTree(..), PropFormula(..), BinOp(..), toSynTree)

import Global



checkSyntax :: OutputCapable m => FilePath -> a -> Submission -> LangM m
checkSyntax _ _ (_,_,_,_,Table xs,_) = do
  when (nubOrd atomicRows /= atomicRows) $ refuse $ indent $ bothLangs $
      "Mindestens eine Belegung kommt in der Wahrheitstafel mehrfach vor. " ++
      "Es müssen alle Belegungen genau einmal vorkommen."
  when (atomicCols == map reverse #{startingTable}) $ refuse $ indent $ bothLangs $
      "Die Spalten der atomaren Formeln sind invertiert. " ++
      "Bitte legen Sie die Tafel so an wie in der Vorlesung vorgegeben."
  assertion (atomicCols == #{startingTable}) $ bothLangs
    "Spalten der atomaren Formeln ergeben eine korrekte (aufsteigend geordnete) Wahrheitstafel?"
  pure ()
  where
    columns = map snd xs
    atomicCols = take staticColumns columns
    atomicRows = filter (notElem Nothing) $ transpose atomicCols

truthValuesToBinaryToIndex :: [Bool] -> Int
truthValuesToBinaryToIndex = foldl (\\acc value -> acc * 2 + if value then 1 else 0) 0

generateTruthTable :: [Bool] -> [[Maybe TruthValue]]
generateTruthTable solutionValues =
  let solIndex = truthValuesToBinaryToIndex solutionValues
  in [[ if i == solIndex then
         Just (TruthValue True)
       else
         Just (TruthValue False)
     | i <- [0..7] ]]


checkSemantics :: OutputCapable m => FilePath -> (a,([Bool],[SynTree BinOp Char])) -> Submission -> Rated m
checkSemantics _ (_,(solutionValues,formulaParts)) (f1,f2,f3,f,Table xs,n) = do
  let correctParts = zipWith (\\fSol g -> isSemanticEqual fSol (toSynTree g)) formulaParts [f1,f2,f3]
  yesNo (and correctParts) $ bothLangs
    "Aussagen sind korrekt übersetzt?"

  let correctFormula = isSemanticEqual (toSynTree f) solutionFormula ||
                       (isSemanticEqual (toSynTree f) (foldr1 (Binary And) (map toSynTree [f1, f2, f3])))
  yesNo correctFormula $ bothLangs
    "Gesamtformel ist korrekt?"

  let correctLast = drop (staticColumns+emptyColumns) columns == generateTruthTable solutionValues
  yesNo correctLast $ bothLangs
    "Spalte F der Wahrheitstafel ist korrekt?"

  let correctNames = n == listOfLiars
  yesNo correctNames $ bothLangs
    "Auswahl der Lügner ist korrekt?"
  let points = (if (and correctParts) then 0.4 else 0.0) +
               (if correctFormula then 0.2 else 0.0) +
               (if correctLast then 0.2 else 0.0) +
               (if correctNames then 0.2 else 0.0)
  res <- printSolutionAndAssertMinimum (MinimumThreshold (1 % 4)) IndefiniteArticle maybeAnswer points
  pure res
    where
      solutionFormula = foldr1 (Binary And) formulaParts
      listOfLiars = (map fst) $ filter (not . snd) (zip allNamen solutionValues)
      columns = map snd xs
      maybeAnswer = flip (++) (show listOfLiars) <$>
        if showSolution
            then Just ("Formel: " ++ simplestDisplay solutionFormula ++ "\\nKorrekte Einträge in Wahrheitstafel.\\nLügner: ")
            else Nothing

|]


=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks
import LogicTasks.Keys (keyHeading, basicOpKey, arrowsKey)

import Global
import Trees.Types
import Data.Text (Text, unpack)


description :: OutputCapable m => FilePath -> ([Text],a) -> LangM m
description _ (hints,_) = do
    paragraph $ bothLangs
      ("Ein Logiker irrt auf dem Campus herum, um seinen Hörsaal zu finden. " ++
       "Er fragt drei Studierende (mit den ausgefallenen Namen A, B, C), wo er den Raum LB 107 finden kann. " ++
       "Diese Studierenden sagen (jeweils) immer die Wahrheit oder lügen immer. " ++
       "Um die Zuverlässigkeit der Antworten zu überprüfen, fragt er die drei Studierenden, ob die anderen lügen, " ++
       "und erhält folgende Antworten:")
    enumerateM (bothLangs . (++ ")") . show) (zip [1..] (map (bothLangs . unpack) hints))
    paragraph $ bothLangs
      ("Übersetzen Sie die Hinweise und die Kombination dieser jeweils in eine aussagenlogische Formel. " ++
       "Geben Sie die Formeln in die entsprechend benannten Textfelder ein.")
    paragraph $ bothLangs
      ("Wer lügt? Leiten Sie Ihr Ergebnis mittels Wahrheitstafel her. " ++
       "Füllen Sie dabei alle benannten Spalten vollständig aus. " ++
       "Sie können Hilfsspalten verwenden. Kreuzen Sie anschließend die entsprechenden Namen an.")
    paragraph $ bothLangs
      ("Verwenden Sie dabei die atomaren Formeln A, B, C mit der Interpretation, " ++
      "dass eine Zuordnung von 'wahr' dafür steht, dass die entsprechende Person die Wahrheit sagt.")
    keyHeading
    basicOpKey True
    arrowsKey
    pure ()


=============================================

module Parse (parseSubmission) where


import Control.OutputCapable.Blocks (LangM', OutputCapable, ReportT)
import Control.OutputCapable.Blocks.Generic (($>>=))
import Data.List.Extra        (chunksOf, transpose)
import FlexTask.Generic.Parse (
  Parse(..),
  displayInputAnd,
  escaped,
  parseInstanceMultiChoice,
  parseWithFallback,
  parseWithOrReport,
  reportWithFieldNumber
  )
import LogicTasks.Formula      (TruthValue)
import Formula.Parsing.Delayed (
  complainAboutMissingParenthesesIfNotFailingOn,
  )
import ParsingHelpers          (fully)
import Trees.Parsing           ()
import Trees.Types             (PropFormula(..))

import qualified Formula.Parsing as FP

import Global


instance Parse TruthValue where
  formParser = escaped FP.parser


instance Parse [Namen] where
  formParser = parseInstanceMultiChoice


makeTable :: [Maybe (PropFormula Char)] -> [Maybe TruthValue] -> Table
makeTable headers values = Table $ zip allHeaders formattedTruthValues
  where
    allHeaders = map (Just . Atomic) "ABC" ++ headers
    formattedTruthValues = transpose $ chunksOf totalColumns values


parseSubmission :: (Monad m, OutputCapable (ReportT o m)) => String -> LangM' (ReportT o m) Submission
parseSubmission input =
  parseWithOrReport formParser reportWithFieldNumber input $>>= \((f1,f2,f3),f,headers,columns,names) ->
    parseIt f1 $>>= \parsedf1 ->
      parseIt f2 $>>= \parsedf2 ->
        parseIt f3 $>>= \parsedf3 ->
          parseIt f $>>= \parsedf ->
            traverse (traverse parseIt) headers $>>= \parsedHeaders ->
              pure (parsedf1,parsedf2,parsedf3,parsedf, makeTable parsedHeaders columns, names)
  where
    parseIt =
      parseWithFallback
        (fully FP.parser)
        (displayInputAnd complainAboutMissingParenthesesIfNotFailingOn)
        (fully FP.formulaSymbolParser)
