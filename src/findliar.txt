module Global where


import Control.OutputCapable.Blocks
import LogicTasks.Formula (TruthValue(..))



instance Eq TruthValue where
  (TruthValue a) == (TruthValue b) = a == b

newtype Table = Table [(Maybe String, [Maybe TruthValue])] deriving (Eq,Show)

data Namen = A | B | C deriving (Eq,Enum,Bounded,Show,Ord)

type Submission = (String,String,String,String,Table,[Namen])


emptyColumns, staticColumns, totalColumns, rows :: Int
emptyColumns  = 4
staticColumns = 3
staticColsEnd = 1
totalColumns  = staticColumns + emptyColumns + staticColsEnd
rows          = 2^staticColumns


bothLangs :: OutputCapable m => String -> LangM m
bothLangs s = translate $ german s >> english s

=============================================

{-# language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# language QuasiQuotes #-}
{-# language RecordWildCards #-}
{-# language TupleSections #-}

module TaskData (getTask) where


import Control.Monad.Reader    (reader)
import Data.Char               (digitToInt)
import Data.List               (transpose, sort)
import Data.Maybe              (fromJust)
import Data.Text               (Text, pack)
import Data.String.Interpolate (i)
import FlexTask.FormUtil (
  ($$>),
  addCss,
  addNameAndCssClass,
  getFormData,
  )
import FlexTask.Generic.Form (
  Alignment(..),
  FieldInfo,
  Formify(..),
  formify,
  formifyInstanceMultiChoice,
  single,
  buttonsEnum
  )
import FlexTask.YesodConfig    (Handler, FlexForm, Rendered)
import LogicTasks.Formula      (TruthValue(..))
import Numeric                 (showBin)
import Test.QuickCheck.Arbitrary (arbitrary)
import Test.QuickCheck.Gen
import Yesod

import Trees.Types (BinOp(..), SynTree(..))
import Trees.Print (simplestDisplay)

import Global




instance MonadFail Gen where
  fail = error


getParticipants :: Gen [Bool]
getParticipants = vectorOf 4 arbitrary `suchThat` \bs -> or bs && not (and bs)


getTask :: Gen (String, String, IO ([String],String))
getTask = do
    d@(x,y,z,_) <- taskData
    let (formulas,hints) = makeHintsAndFormula d
    let lying = sort $ map (fromChar . fst) $ filter (\(_,x) -> x == False) [x,y,z]
    let f = foldr1 (Binary And) formulas
    pure (show (hints,(lying,formulas,f)), checkers False True, getFormData form)
  where
    fromChar 'A' = A
    fromChar 'B' = B
    fromChar 'C' = C
    form :: Rendered
    form = formify (Nothing :: Maybe (String,String,String))
                     [[single "Aussage 1) :"],[single "Aussage 2) :"],[single "Aussage 3) :"]] $$>
           formify (Nothing :: Maybe (String))
                     [[single "Formel F="]] $$>
           tableForm ["A","B","C"] $$>
           formify (Nothing :: Maybe [Namen])
                     [[buttonsEnum Vertical "Wer lügt?" (pack . show @Namen)]]



taskData :: Gen ((Char, Bool), (Char, Bool), (Char, Bool), Bool)
taskData = do
  permutation <- shuffle ['A','B','C']
  values <- vectorOf 3 arbitrary
  v <- arbitrary
  case zip permutation values of
    [(p0,v0), (p1,v1), (p2,v2)]
      -> return ((p0,v0), (p1,v1), (p2,v2), v)
    _
      -> error "This is impossible!"

makeHintsAndFormula :: ((Char, Bool), (Char, Bool), (Char, Bool), Bool) -> ([SynTree BinOp Char], [Text])
makeHintsAndFormula ((xn, xw), (yn, yw), (zn, zw), v) = (parts, hints)
  where
    xYnOrNotYn = if xw == yw then Leaf yn else Not (Leaf yn)
    yZnOrNotZn = if yw == zw then Leaf zn else Not (Leaf zn)
    zXnOrNotXn = if v then Leaf xn else Not (Leaf xn)
    zYnOrNotYn = if (xw == yw) == v then Not (Leaf yn) else Leaf yn
    zOperator :: String
      | zw                                   = " oder"
      | isNot zXnOrNotXn == isNot zYnOrNotYn = " und"
      | otherwise                            = ", aber"

    parts = [px, py, pz]
    px = Binary Equi (Leaf xn) xYnOrNotYn
    py = Binary Equi (Leaf yn) yZnOrNotZn
    pz = Binary Equi (Leaf zn) (Binary (if zw then Or else And) zXnOrNotXn zYnOrNotYn)

    hints = [hx, hy, hz]
    hx = [i|#{xn} sagt: "#{yn}#{if isNot xYnOrNotYn then " lügt"::String else sdW}."|]
    hy = [i|#{yn} sagt: "#{zn}#{if isNot yZnOrNotZn then " lügt"::String else sdW}."|]
    hz = [i|#{zn} sagt: "#{xn}#{statement}."|]

    isNot :: SynTree b c -> Bool
    isNot (Not _) = True
    isNot _       = False

    sdW :: String
    sdW = " sagt die Wahrheit"

    statement :: String
    statement = if isNot zXnOrNotXn == isNot zYnOrNotYn
      then
        let truthStatement = if isNot zXnOrNotXn
            then "lügen"::String
            else "sagen die Wahrheit"::String
        in [i|#{zOperator} #{yn} #{truthStatement}|]
      else
        let partX = if isNot zXnOrNotXn then " lügt"::String else sdW
            partY = if isNot zYnOrNotYn then " lügt"::String else sdW
        in [i|#{partX}#{zOperator} #{yn}#{partY}|]






tableForm :: [Text] -> Rendered
tableForm staticHeaders =
  addCss css $ reader $ \extra -> do
    let addAttr a fs@FieldSettings{..} = fs {fsAttrs = a : fsAttrs}
        headerTextField t = mopt textField (addAttr ("tabindex",pack $ show 1) $ addNameAndCssClass t "header") Nothing
        tableTextField tabOrd t = mopt textField (addAttr ("tabindex",pack $ show tabOrd) $ addNameAndCssClass t "tableInput") Nothing

        headerList = replicate emptyColumns "headers"
        cellList = replicate rows "cells"

    headersRes <- traverse headerTextField headerList
    columnsRes <- traverse (\i -> traverse (tableTextField i) cellList) [2..totalColumns+1]
    let headers = map snd headersRes
        rows = transpose $ map (map snd) columnsRes
    pure ( ["headers","cells"]
         , [whamlet|
              #{extra}
              <table>
                <tr>
                  $forall sh <- staticHeaders
                    <th>#{sh}
                  $forall header <- headers
                    <th>^{fvInput header}
                  <th>F
                $forall row <- rows
                  <tr>
                    $forall input <- row
                      <td>^{fvInput input}|]
         )
  where
    css = [cassius|
      #flexident287
        width: 600px
        margin: 10px 10px
      .header
        width: 100%
        text-align: center
        height: 25px
      .tableInput
        width: 100%
        text-align: center
      th, td
        border: 1px solid black
        border-collapse: collapse
        text-align: center
      table tr th:nth-child(-n+3)
        width: 20px
      table tr td:nth-child(-n+3)
        height: 25px
      table tr th:nth-child(n+4)
        width: 125px
      table tr th:nth-child(n+8)
        width: 25px
      table tr th:last-child
        padding: 10px 0px
      table
        table-layout: fixed
    |]




instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



startingTable :: [[Maybe TruthValue]]
startingTable = map (Just . TruthValue . toEnum . digitToInt) <$>
    transpose (pad . (`showBin` "") <$> [0..rows -1])
  where pad s = replicate (staticColumns - length s) '0' ++ s



checkers :: Bool -> Bool -> String
checkers tableRequired showSolution = [i|

{-\# language ApplicativeDo \#-}
{-\# language OverloadedStrings \#-}

module Check (checkSemantics, checkSyntax) where


import Control.Monad (when)
import Control.OutputCapable.Blocks
import Data.Foldable (toList)
import Data.List     (intercalate, isInfixOf)
import Data.Maybe    (catMaybes, fromJust)
import Data.Map      (fromList)
import Data.Ratio    ((%))

import LogicTasks.Formula (TruthValue(..), isSemanticEqual, convert)
import LogicTasks.Parsing (allSymbolParser, parser)
import Formula.Parsing.Delayed
import Formula.Parsing.Type (Parse(..))
import Text.Parsec.Char (string)
import Trees.Types (SynTree(..), PropFormula(..), BinOp(..))
import Trees.Print (simplestDisplay)

import qualified SAT.MiniSat as Sat
import qualified Data.Text   as T

import Global

import Text.Parsec.String

instance (Parse a,Parse b,Parse c,Parse d, Parse e) => Parse (a,b,c,d,e) where
  parser = do
    string "("
    a <- parser
    string ","
    b <- parser
    string ","
    c <- parser
    string ","
    d <- parser
    string ","
    e <- parser
    string ")"
    pure (a,b,c,d,e)


stringTuple :: String -> String -> String -> String -> String -> String
stringTuple s1 s2 s3 s4 s5 = '(':s1 ++ ',':s2 ++ ',':s3 ++ ',':s4 ++ ',':s5 ++ ")"


stringList :: [Maybe String] -> String
stringList xs = '[': intercalate "," (map stringMaybe xs) ++ "]"
  where
    stringMaybe Nothing = "Nothing"
    stringMaybe (Just s) = s



checkSyntax :: OutputCapable m => a -> FilePath -> Submission -> LangM m
checkSyntax _ _ (f1,f2,f3,f,Table xs, names) =
  parseDelayedWithAndThen
    parser
    complainAboutMissingParenthesesIfNotFailingOn
    allSymbolParser
    (checkSyntax' names)
    $ delayed $ stringTuple (stringList $ map fst xs) f1 f2 f3 f

checkSyntax' :: OutputCapable m => [Namen] -> ([Maybe (PropFormula Char)],PropFormula Char, PropFormula Char, PropFormula Char, PropFormula Char) -> LangM m
checkSyntax' n (fs,f1,f2,f3,f) = pure ()

toTree :: PropFormula Char -> SynTree BinOp Char
toTree (Atomic c) = Leaf c
toTree (Neg p) = Not $ toTree p
toTree (Brackets p) = toTree p
toTree (Assoc op l r) = Binary op (toTree l) (toTree r)



checkSemantics :: OutputCapable m => (a,([Namen],[SynTree BinOp Char],SynTree BinOp Char)) -> FilePath -> Submission -> Rated m
checkSemantics (_isSemanticEqual,(lying,formulas,solF)) _ (f1,f2,f3,f,Table xs,names) =
  withDelayedSucceeding
    (checkSemantics' formulas lying columns solF names)
    parser
    $ delayed $ stringTuple (stringList headers) f1 f2 f3 f
  where
    (headers,columns) = unzip xs


checkSemantics' :: OutputCapable m => [SynTree BinOp Char] -> [Namen] -> [[Maybe TruthValue]] -> SynTree BinOp Char
  -> [Namen] -> ([Maybe (PropFormula Char)],PropFormula Char, PropFormula Char, PropFormula Char, PropFormula Char) -> Rated m
checkSemantics' formulas lying columns solF n (headers,f1,f2,f3,f) = do
  let correctStart = take staticColumns columns == #{startingTable}
  yesNo correctStart $ bothLangs
      "Spalten der atomaren Formeln ergeben sinnvolle Wahrheitstafel?"
  let correctNames = n == lying
  yesNo correctNames $ bothLangs
    ("Die Auswahl der Lügner ist korrekt?" ++ show lying ++ " " ++ show n)
  let correctFormula = isSemanticEqual (toTree f) solF
  yesNo correctFormula $ bothLangs
    ("Gesamtformel ist korrekt?" ++ simplestDisplay (toTree f) ++ " " ++ simplestDisplay solF)

  pure 1


|]


=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks

import Global
import Trees.Types


description :: OutputCapable m => FilePath -> ([String],a) -> LangM m
description _ (hints,_) = do
    paragraph $ bothLangs
      "Ein Logiker irrt auf dem Campus herum, um seinen Hörsaal zu finden. Er fragt drei Studierende (mit den ausgefallenen Namen A, B, C), wo er den Raum LB 107 finden kann. Diese Studierenden sagen (jeweils) immer die Wahrheit oder lügen immer. Um die Zuverlässigkeit der Antworten zu überprüfen, fragt er die drei Studierenden, ob die anderen lügen, und erhält folgende Antworten:"
    itemizeM $ map bothLangs hints
    paragraph $ bothLangs
      "Übersetzen Sie die einzelnen Aussagen und die Kombination aller Aussagen jeweils in eine aussagenlogische Formel. Geben Sie die Formeln in die entsprechend benannten Textfelder ein."
    paragraph $ bothLangs
      "Wer lügt? Leiten Sie Ihr Ergebnis mittels Wahrheitstafel her. Füllen Sie dabei alle benannten Spalten vollständig aus. Sie können Hilfsspalten verwenden. Kreuzen Sie dann die entsprechenden Namen an."
    paragraph $ bothLangs
      "Verwenden Sie für die Angabe der Formel die atomaren Formeln A, B, C und die folgenden Operatoren:"
    enumerateM code $ zip ["Negation","Und","Oder","Implikation","Biimplikation"] $ map code ["¬","∧","∨","=>","<=>"]
    pure ()


=============================================

module Parse (parseSubmission) where


import Data.List               (transpose)
import Data.List.Split         (chunksOf)
import FlexTask.Generic.Parse (
  Parse(..),
  parseInstanceMultiChoice,
  escaped,
  useParser
  )
import LogicTasks.Formula      (TruthValue)
import Text.Parsec             (ParseError)
import Trees.Parsing           ()

import qualified Formula.Parsing as FP

import Global



instance (Parse a,Parse b,Parse c,Parse d,Parse e,Parse f) => Parse (a,b,c,d,e,f)

instance Parse TruthValue where
  parseInput = escaped FP.parser


instance Parse [Namen] where
  parseInput = parseInstanceMultiChoice



instance Parse Table where
  parseInput = do
    (headers,values) <- parseInput
    let allHeaders = map (Just . (:[])) "ABC" ++ headers
    pure $ Table $ zip allHeaders $ transpose $ chunksOf totalColumns values



parseSubmission :: String -> Either ParseError Submission
parseSubmission = useParser parseInput
