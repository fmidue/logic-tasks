{-# language DeriveDataTypeable#-}

module Global where


import Control.OutputCapable.Blocks
import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..))
import Data.Text (Text,pack)
import Data.Data (Data)


newtype Table = Table [(Maybe String, [Maybe TruthValue])] deriving (Eq,Show)

data Namen = A | B | C deriving (Eq,Enum,Bounded,Show,Ord,Data)

type Submission = (String,String,String,String,Table,[Namen])
type TaskData = ([Text],([Namen],[Bool],[SynTree BinOp Char],SynTree BinOp Char))


emptyColumns, staticColumns, staticColsEnd, totalColumns, rows :: Int
emptyColumns  = 4
staticColumns = 3
staticColsEnd = 1
totalColumns  = staticColumns + emptyColumns + staticColsEnd
rows          = 2^staticColumns

showSolution :: Bool
showSolution  = True



bothLangs :: OutputCapable m => String -> LangM m
bothLangs s = translate $ german s >> english s

=============================================

{-# language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# language QuasiQuotes #-}
{-# language RecordWildCards #-}
{-# language TupleSections #-}

module TaskData (getTask) where


import Data.Char               (digitToInt)
import Data.List               (transpose, sortOn)
import Data.String             (fromString)
import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.FormUtil (
  ($$>),
  addCss,
  getFormData,
  )
import FlexTask.Generic.Form (
  Alignment(..),
  Formify(..),
  formify,
  formifyInstanceMultiChoice,
  single,
  buttonsEnum
  )
import FlexTask.Types          (HtmlDict)
import FindLiarTask
import LogicTasks.Forms        (tableForm)
import LogicTasks.Formula      (TruthValue(..))
import Numeric                 (showBin)
import Test.QuickCheck.Gen
import Yesod

import Trees.Types (BinOp(..), SynTree(..))

import Global




instance MonadFail Gen where
  fail = error


getTask :: Gen (TaskData, String, IO ([Text], HtmlDict))
getTask = do
    d@(x, y, z, _) <- taskData
    let (formulas, hints) = makeHintsAndFormula d

        dataSortedOnName = sortOn fst [x, y, z]
        (formulasSorted, hintsSorted) = unzip $ sortOn snd $ zip formulas hints

        listOfLiars = map (fromChar . fst) $ filter (not . snd) dataSortedOnName
        solutionValues = map snd dataSortedOnName
        combinedFormula = foldr1 (Binary And) formulasSorted

    pure ((hintsSorted, (listOfLiars, solutionValues, formulasSorted, combinedFormula)),
          checkers,
          getFormData form)
  where
    form = formify (Nothing :: Maybe (String, String, String))
             [[single "1) "],
             [single "2) "],
             [single "3) "]] $$>
           formify (Nothing :: Maybe String)
             [[single "Gesamtformel F="]] $$>
           addCss formulaCss (tableForm emptyColumns rows ["A","B","C"] ["F"]) $$>
           formify (Nothing :: Maybe [Namen])
             [[buttonsEnum Vertical "Wer lügt?" (fromString . show @Namen)]]

    fromChar 'A' = A
    fromChar 'B' = B
    fromChar 'C' = C
    fromChar  _  = error "invalid Name"


    formulaCss = [cassius|
       th, td
        border: 1px solid black
        border-collapse: collapse
        text-align: center
      table tr th:nth-child(-n+3)
        width: 20px
      table tr td:nth-child(-n+3)
        height: 25px
      table tr th:nth-child(n+4)
        width: 125px
      table tr th:nth-child(n+8)
        width: 25px
      table tr th:last-child
        padding: 10px 0px
       |]



instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



startingTable :: [[Maybe TruthValue]]
startingTable = map (Just . TruthValue . toEnum . digitToInt) <$>
    transpose (pad . (`showBin` "") <$> [0..rows -1])
  where pad s = replicate (staticColumns - length s) '0' ++ s



checkers :: String
checkers = [i|

{-\# language ApplicativeDo \#-}
{-\# language OverloadedStrings \#-}
{-\# language TypeApplications \#-}


module Check (checkSemantics, checkSyntax) where

import Control.Monad (when)
import Control.OutputCapable.Blocks
import Data.Containers.ListUtils (nubOrd)
import Data.List     (intercalate, transpose)
import Data.Ratio    ((%))


import LogicTasks.Formula (TruthValue(..), isSemanticEqual)
import LogicTasks.Parsing (allSymbolParser)
import Formula.Parsing.Delayed
import Formula.Parsing.Type (Parse(..))
import Text.Parsec.Char (string)
import Text.Parsec.String (Parser)
import Trees.Print (simplestDisplay)
import Trees.Types (SynTree(..), PropFormula(..), BinOp(..), toSynTree)

import Global

instance (Parse a,Parse b,Parse c,Parse d, Parse e) => Parse (a,b,c,d,e) where
  parser = do
    string "("
    a <- parser
    string ","
    b <- parser
    string ","
    c <- parser
    string ","
    d <- parser
    string ","
    e <- parser
    string ")"
    pure (a,b,c,d,e)


instance (Parse a,Parse b,Parse c,Parse d) => Parse (a,b,c,d) where
  parser = do
    string "("
    a <- parser
    string ","
    b <- parser
    string ","
    c <- parser
    string ","
    d <- parser
    string ")"
    pure (a,b,c,d)


stringTuple4 :: String -> String -> String -> String -> String
stringTuple4 s1 s2 s3 s4 = '(':s1 ++ ',':s2 ++ ',':s3 ++ ',':s4 ++ ")"

stringTuple5 :: String -> String -> String -> String -> String -> String
stringTuple5 s1 s2 s3 s4 s5 = '(':s1 ++ ',':s2 ++ ',':s3 ++ ',':s4 ++ ',':s5 ++ ")"


stringList :: [Maybe String] -> String
stringList xs = '[': intercalate "," (map stringMaybe xs) ++ "]"
  where
    stringMaybe Nothing = "Nothing"
    stringMaybe (Just s) = s


checkSyntax :: OutputCapable m => FilePath -> a -> Submission -> LangM m
checkSyntax _ _ (f1,f2,f3,f,Table xs, _) =
  parseDelayedWithAndThen
    (parser :: Parser ([Maybe (PropFormula Char)], PropFormula Char, PropFormula Char, PropFormula Char, PropFormula Char))
    complainAboutMissingParenthesesIfNotFailingOn
    allSymbolParser
    (\\_ -> checkSyntax' columns)
    $ delayed (stringTuple5 (stringList headers) f1 f2 f3 f)
  where
    (headers,columns) = unzip xs

checkSyntax' :: OutputCapable m => [[Maybe TruthValue]] -> LangM m
checkSyntax' columns = do
  when (nubOrd atomicRows /= atomicRows) $ refuse $ indent $ bothLangs $
      "Mindestens eine Belegung kommt in der Wahrheitstafel mehrfach vor. " ++
      "Es müssen alle Belegungen genau einmal vorkommen."
  when (atomicCols == map reverse #{startingTable}) $ refuse $ indent $ bothLangs $
      "Die Spalten der atomaren Formeln sind invertiert. " ++
      "Bitte legen Sie die Tafel so an wie in der Vorlesung vorgegeben."
  assertion (atomicCols == #{startingTable}) $ bothLangs
    "Spalten der atomaren Formeln ergeben eine korrekte (aufsteigend geordnete) Wahrheitstafel?"
  pure ()
  where
    atomicCols = take staticColumns columns
    atomicRows = filter (notElem Nothing) $ transpose atomicCols

truthValuesToBinaryToIndex :: [Bool] -> Int
truthValuesToBinaryToIndex = foldl (\\acc value -> acc * 2 + if value then 1 else 0) 0

generateTruthTable :: [Bool] -> [[Maybe TruthValue]]
generateTruthTable solutionValues =
  let solIndex = truthValuesToBinaryToIndex solutionValues
  in [[ if i == solIndex then
         Just (TruthValue True)
       else
         Just (TruthValue False)
     | i <- [0..7] ]]


checkSemantics :: OutputCapable m => FilePath -> (a,([Namen],[Bool],[SynTree BinOp Char],SynTree BinOp Char)) -> Submission -> Rated m
checkSemantics _ (_isSemanticEqual,(lying,solutionValues,formulas,solF)) (f1,f2,f3,f,Table xs,names) =
  withDelayedSucceeding
    (checkSemantics' formulas lying solutionValues columns solF names)
    parser
    $ delayed $ stringTuple4 f1 f2 f3 f
  where
    (_,columns) = unzip xs

checkSemantics' :: OutputCapable m => [SynTree BinOp Char] -> [Namen] -> [Bool] -> [[Maybe TruthValue]] -> SynTree BinOp Char
  -> [Namen] -> (PropFormula Char, PropFormula Char, PropFormula Char, PropFormula Char) -> Rated m
checkSemantics' formulas lying solutionValues columns solF n (f1,f2,f3,f) = do

  let correctParts = zipWith (\\fSol g -> isSemanticEqual fSol (toSynTree g)) formulas [f1,f2,f3]
  yesNo (and correctParts) $ bothLangs
    "Aussagen sind korrekt übersetzt?"

  let correctFormula = isSemanticEqual (toSynTree f) solF ||
                       (isSemanticEqual (toSynTree f) (toSynTree (foldr1 (Assoc And) (map Brackets [f1,f2,f3]))))
  yesNo correctFormula $ bothLangs
    "Gesamtformel ist korrekt?"

  let correctLast = drop (staticColumns+emptyColumns) columns == generateTruthTable solutionValues
  yesNo correctLast $ bothLangs
    "Spalte F der Wahrheitstafel ist korrekt?"

  let correctNames = n == lying
  yesNo correctNames $ bothLangs
    "Auswahl der Lügner ist korrekt?"
  let points = (if (and correctParts) then 0.4 else 0.0) +
               (if correctFormula then 0.2 else 0.0) +
               (if correctLast then 0.2 else 0.0) +
               (if correctNames then 0.2 else 0.0)
  res <- printSolutionAndAssertMinimum (MinimumThreshold (1 % 4)) IndefiniteArticle maybeAnswer points
  pure res
    where
      maybeAnswer = flip (++) (show lying) <$>
        if showSolution
            then Just ("Formel: " ++ simplestDisplay solF ++ "\\nKorrekte Einträge in Wahrheitstafel.\\nLügner: ")
            else Nothing

|]


=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks
import LogicTasks.Keys (keyHeading, basicOpKey, arrowsKey)

import Global
import Trees.Types
import Data.Text (Text, unpack)


description :: OutputCapable m => FilePath -> ([Text],a) -> LangM m
description _ (hints,_) = do
    paragraph $ bothLangs
      ("Ein Logiker irrt auf dem Campus herum, um seinen Hörsaal zu finden. " ++
       "Er fragt drei Studierende (mit den ausgefallenen Namen A, B, C), wo er den Raum LB 107 finden kann. " ++
       "Diese Studierenden sagen (jeweils) immer die Wahrheit oder lügen immer. " ++
       "Um die Zuverlässigkeit der Antworten zu überprüfen, fragt er die drei Studierenden, ob die anderen lügen, " ++
       "und erhält folgende Antworten:")
    enumerateM (bothLangs . (++ ")") . show) (zip [1..] (map (bothLangs . unpack) hints))
    paragraph $ bothLangs
      ("Übersetzen Sie die Hinweise und die Kombination dieser jeweils in eine aussagenlogische Formel. " ++
       "Geben Sie die Formeln in die entsprechend benannten Textfelder ein.")
    paragraph $ bothLangs
      ("Wer lügt? Leiten Sie Ihr Ergebnis mittels Wahrheitstafel her. " ++
       "Füllen Sie dabei alle benannten Spalten vollständig aus. " ++
       "Sie können Hilfsspalten verwenden. Kreuzen Sie anschließend die entsprechenden Namen an.")
    paragraph $ bothLangs
      ("Verwenden Sie dabei die atomaren Formeln A, B, C mit der Interpretation, " ++
      "dass eine Zuordnung von 'wahr' dafür steht, dass die entsprechende Person die Wahrheit sagt.")
    keyHeading
    basicOpKey True
    arrowsKey
    pure ()


=============================================

module Parse (parseSubmission) where


import Data.List               (transpose)
import Data.List.Split         (chunksOf)
import FlexTask.Generic.Parse (
  Parse(..),
  parseInstanceMultiChoice,
  parseWithOrReport,
  reportWithFieldNumber
  )
import LogicTasks.Formula      (TruthValue)
import Text.Parsec             (ParseError)
import Trees.Parsing           ()

import qualified Formula.Parsing as FP

import Global




instance Parse TruthValue where
  parseInput = escaped FP.parser


instance Parse [Namen] where
  parseInput = parseInstanceMultiChoice



instance Parse Table where
  parseInput = do
    (headers,values) <- parseInput
    let allHeaders = map (Just . (:[])) "ABC" ++ headers ++ [Just "F"]
    pure $ Table $ zip allHeaders $ transpose $ chunksOf totalColumns values



parseSubmission :: (Monad m, OutputCapable (ReportT o m)) => String -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber $>>= \(f1,f2,f3,f,Table xs,names) -> undefined
  where
    parseIt =
      parseWithFallback
        (fully parser)
        (displayInputAnd complainAboutMissingParenthesesIfNotFailingOn)
        (fully formulaSymbolParser)

