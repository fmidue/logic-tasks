{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# language DeriveDataTypeable#-}

module Global where


import Control.OutputCapable.Blocks
import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..), PropFormula(..))
import Data.Text (Text)
import Data.Data (Data)


newtype Table = Table [(Maybe (PropFormula Char), [Maybe TruthValue])] deriving (Eq,Show)

data Namen = A | B | C deriving (Eq,Enum,Bounded,Show,Ord,Data)
allNamen :: [Namen]
allNamen = [minBound .. maxBound]

type Submission = ([PropFormula Char],PropFormula Char,Table,[Namen])
type TaskData = ([Text],[Bool],[SynTree BinOp Char])



bothLangs :: OutputCapable m => String -> LangM m
bothLangs s = translate $ german s >> english s

=============================================

module TaskSettings where

import Data.Char     (digitToInt)
import Data.List     (transpose)
import Numeric       (showBin)

import Control.OutputCapable.Blocks (
  LangM,
  OutputCapable,
  indent,
  refuse,
  text,
  )

import LogicTasks.Formula (TruthValue(..))


emptyColumns, staticColumns, staticColsEnd, totalColumns, rows :: Int
emptyColumns  = 4
staticColumns = 3
staticColsEnd = 1
totalColumns  = staticColumns + emptyColumns + staticColsEnd
rows          = 2^staticColumns

startingTable :: [[Maybe TruthValue]]
startingTable = map (Just . TruthValue . toEnum . digitToInt) <$>
    transpose (pad . (`showBin` "") <$> [0 .. rows - 1])
  where pad s = replicate (staticColumns - length s) '0' ++ s

showSolution, printFeedbackImmediately :: Bool
showSolution  = True
printFeedbackImmediately = True


validateSettings :: OutputCapable m => LangM m
validateSettings
  | emptyColumns < 3 = refuse $ indent $ text
      "Die Anzahl der leeren Spalten ist kleiner als die Anzahl der Hinweise."
  | totalColumns > 18 = refuse $ indent $ text $
      "Die Tabelle enthält zu viele Spalten. " ++
      "Das Eingabeformular kann bei über 18 Spalten nicht mehr korrekt angezeigt werden."
  | otherwise = pure ()

=============================================


{-# language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# language QuasiQuotes #-}
{-# language RecordWildCards #-}
{-# language TupleSections #-}

module TaskData (getTask) where


import Data.List               (sortOn)
import Data.String             (fromString)
import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.FormUtil (
  ($$>),
  addCss,
  getFormData,
  )
import FlexTask.Generic.Form (
  Alignment(..),
  Formify(..),
  formify,
  formifyInstanceMultiChoice,
  list,
  single,
  buttonsEnum
  )
import FlexTask.Types          (HtmlDict)
import FindLiarTask
import LogicTasks.Forms        (tableForm)
import Test.QuickCheck.Gen
import Yesod


import Global
import TaskSettings




instance MonadFail Gen where
  fail = error


getTask :: Gen (TaskData, String, IO ([Text], HtmlDict))
getTask = do
    d@(x, y, z, _) <- taskData
    let (formulas, hints) = makeHintsAndFormula d

        dataSortedOnName = sortOn fst [x, y, z]
        (formulasSorted, hintsSorted) = unzip $ sortOn snd $ zip formulas hints

        solutionValues = map snd dataSortedOnName

    pure ((hintsSorted, solutionValues, formulasSorted),
          checkers,
          getFormData form)
  where
    form = formify (Nothing :: Maybe [String])
        [[list Vertical [ "1) ", "2) ", "3) "]]] $$>
        formify (Nothing :: Maybe String)
          [[single "Gesamtformel F="]] $$>
        addCss formulaCss (tableForm emptyColumns rows ["A","B","C"] ["F"]) $$>
        formify (Nothing :: Maybe [Namen])
          [[buttonsEnum Vertical "Wer lügt?" (fromString . show @Namen)]]


    formulaCss = [cassius|
       th, td
        border: 1px solid black
        border-collapse: collapse
        text-align: center
      table tr th:nth-child(-n+3)
        width: 20px
      table tr td:nth-child(-n+3)
        height: 25px
      table tr th:nth-child(n+4)
        width: 125px
      table tr th:nth-child(n+8)
        width: 25px
      table tr th:last-child
        padding: 10px 0px
       |]



instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



checkers :: String
checkers = [i|

{-\# language ApplicativeDo \#-}
{-\# language OverloadedStrings \#-}


module Check (checkSemantics, checkSyntax) where

import Control.Monad (when)
import Control.OutputCapable.Blocks
import Data.Containers.ListUtils (nubOrd)
import Data.List     (transpose, intercalate)
import Data.Maybe    (fromJust)
import Data.Ratio    ((%))
import Data.Text     (Text, unpack)

import LogicTasks.Formula (
  Formula(..),
  TruthValue(..),
  isSemanticEqual
  )
import Trees.Formula ()
import Trees.Print (simplestDisplay)
import Trees.Types (
  SynTree(..),
  BinOp(..),
  toSynTree
  )


import Global

toConfigInverted :: [Namen] -> [(Char,Bool)]
toConfigInverted liars = map (\\x -> (nameMatch x, notElem x liars)) allNamen
  where
    nameMatch A = 'A'
    nameMatch B = 'B'
    nameMatch C = 'C'

printConfig :: [(Char,Bool)] -> String
printConfig config =  intercalate ", " (map (\\(a,b) -> [a] ++ "=" ++ show (if b then (1 :: Int) else (0 :: Int))) config)

feedbackCompareHints :: OutputCapable m => [Text] -> [Namen] -> LangM m
feedbackCompareHints unmatchedHints identifiedLiars = do
  indent $ bothLangs $
    "Widerspruch gefunden: Die ausgewählten Lügner sind: " ++
    show identifiedLiars ++ "." ++
    " Das passt jedoch nicht zu dem Hinweis: " ++
    unpack (unmatchedHints!!0)

feedbackCompareChosenLiars :: OutputCapable m => [(Char, Bool)] -> [SynTree BinOp Char] -> LangM m
feedbackCompareChosenLiars configFromLiars wrongLiars = do
  indent $ bothLangs $
    "Widerspruch gefunden: Die zu der getroffenen Lügner-Auswahl passende Belegung ist: " ++
    printConfig configFromLiars ++ "." ++
    " Jedoch wertet die angegebene Teilformel: " ++
    simplestDisplay (wrongLiars!!0) ++
    " unter dieser Belegung zu 0 (falsch) aus."


checkSyntax :: OutputCapable m => FilePath -> TaskData -> Submission -> LangM m
checkSyntax _ (hints,_,formulaParts) (submittedParts,_,Table xs,identifiedLiars) = do

  when (nubOrd atomicRows /= atomicRows) $ refuse $ indent $ bothLangs $
      "Mindestens eine Belegung kommt in der Wahrheitstafel mehrfach vor. " ++
      "Es müssen alle Belegungen genau einmal vorkommen."
  let theTable = #{startingTable}
  when (atomicCols == map reverse theTable) $ refuse $ indent $ bothLangs $
      "Die Spalten der atomaren Formeln sind invertiert. " ++
      "Bitte legen Sie die Tafel so an wie in der Vorlesung vorgegeben."
  assertion (atomicCols == theTable) $ bothLangs
    "Spalten der atomaren Formeln ergeben eine korrekte (aufsteigend geordnete) Wahrheitstafel?"

  let wrongLiars = [formula | formula <- map toSynTree submittedParts, not (fromJust (evaluate configFromLiars formula))]
  when (#{printFeedbackImmediately} && not (null wrongLiars)) $
    refuse $ feedbackCompareChosenLiars configFromLiars wrongLiars

  let unmatchedHints = [hint | (formula, hint) <- zip formulaParts hints, not (fromJust (evaluate configFromLiars formula))]
  when (#{printFeedbackImmediately} && not (null unmatchedHints)) $
    refuse $ feedbackCompareHints unmatchedHints identifiedLiars

  pure ()
  where
    configFromLiars = toConfigInverted identifiedLiars
    columns = map snd xs
    atomicCols = take #{staticColumns} columns
    atomicRows = filter (notElem Nothing) $ transpose atomicCols

truthValuesToBinaryToIndex :: [Bool] -> Int
truthValuesToBinaryToIndex = foldl (\\acc value -> acc * 2 + if value then 1 else 0) 0

generateTruthTable :: [Bool] -> [[Maybe TruthValue]]
generateTruthTable solutionValues =
  let solIndex = truthValuesToBinaryToIndex solutionValues
  in [[ if i == solIndex then
         Just (TruthValue True)
       else
         Just (TruthValue False)
     | i <- [0..7] ]]


checkSemantics :: OutputCapable m => FilePath -> ([Text],[Bool],[SynTree BinOp Char]) -> Submission -> Rated m
checkSemantics _ (hints,solutionValues,formulaParts) (submittedParts,f,Table xs,identifiedLiars) = do
  let correctParts = zipWith (\\fSol g -> isSemanticEqual fSol (toSynTree g)) formulaParts submittedParts
  yesNo (and correctParts) $ bothLangs
    "Aussagen sind korrekt übersetzt?"

  let correctFormula = isSemanticEqual (toSynTree f) solutionFormula ||
                       isSemanticEqual (toSynTree f) (foldr1 (Binary And) (map toSynTree submittedParts))
  yesNo correctFormula $ bothLangs
    "Gesamtformel ist korrekt?"

  let unmatchedHints = [hint | (formula, hint) <- zip formulaParts hints, not (fromJust (evaluate configFromLiars formula))]
  when (not #{printFeedbackImmediately} && not (null unmatchedHints)) $
    feedbackCompareHints unmatchedHints identifiedLiars

  let wrongLiars = [formula | formula <- map toSynTree submittedParts, not (fromJust (evaluate configFromLiars formula))]
  when (not #{printFeedbackImmediately} && not (null wrongLiars)) $
    feedbackCompareChosenLiars configFromLiars wrongLiars

  let correctLast = drop (#{staticColumns+emptyColumns}) columns == generateTruthTable solutionValues
  yesNo correctLast $ bothLangs
    "Spalte F der Wahrheitstafel ist korrekt?"

  let correctNames = identifiedLiars == listOfLiars
  yesNo correctNames $ bothLangs
    "Auswahl der Lügner ist korrekt?"
  let points = (if and correctParts then 0.4 else 0.0) +
               (if correctFormula then 0.2 else 0.0) +
               (if correctLast then 0.2 else 0.0) +
               (if correctNames then 0.2 else 0.0)
  res <- printSolutionAndAssertMinimum (MinimumThreshold (1 % 4)) IndefiniteArticle maybeAnswer points
  pure res
    where
      configFromLiars = toConfigInverted identifiedLiars
      solutionFormula = foldr1 (Binary And) formulaParts
      listOfLiars = map fst $ filter (not . snd) (zip allNamen solutionValues)
      columns = map snd xs
      maybeAnswer = #{if showSolution then "Just (" ++ solutionCode ++ ")" else "Nothing"}

|]
  where
    solutionCode = [i|"Formel: " ++ simplestDisplay solutionFormula ++ "\\nKorrekte Einträge in Wahrheitstafel.\\nLügner: " ++ show listOfLiars|]
=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks
import LogicTasks.Keys (keyHeading, basicOpKey, arrowsKey)

import Global
import Data.Text (Text, unpack)


description :: OutputCapable m => FilePath -> ([Text],a,b) -> LangM m
description _ (hints,_,_) = do
    paragraph $ bothLangs
      ("Ein Logiker irrt auf dem Campus herum, um seinen Hörsaal zu finden. " ++
       "Er fragt drei Studierende (mit den ausgefallenen Namen A, B, C), wo er den Raum LB 107 finden kann. " ++
       "Diese Studierenden sagen (jeweils) immer die Wahrheit oder lügen immer. " ++
       "Um die Zuverlässigkeit der Antworten zu überprüfen, fragt er die drei Studierenden, ob die anderen lügen, " ++
       "und erhält folgende Antworten:")
    enumerateM (bothLangs . (++ ")") . show) (zip [1 ::Int ..] (map (bothLangs . unpack) hints))
    paragraph $ bothLangs
      ("Übersetzen Sie die Hinweise und die Kombination dieser jeweils in eine aussagenlogische Formel. " ++
       "Geben Sie die Formeln in die entsprechend benannten Textfelder ein.")
    paragraph $ bothLangs
      ("Wer lügt? Leiten Sie Ihr Ergebnis mittels Wahrheitstafel her. " ++
       "Füllen Sie dabei alle benannten Spalten vollständig aus. " ++
       "Sie können Hilfsspalten verwenden. Kreuzen Sie anschließend die entsprechenden Namen an.")
    paragraph $ bothLangs
      ("Verwenden Sie dabei die atomaren Formeln A, B, C mit der Interpretation, " ++
      "dass eine Zuordnung von 'wahr' dafür steht, dass die entsprechende Person die Wahrheit sagt.")
    keyHeading
    basicOpKey True
    arrowsKey
    pure ()


=============================================

module Parse (parseSubmission) where


import Control.OutputCapable.Blocks (LangM', OutputCapable, ReportT)
import Control.OutputCapable.Blocks.Generic (($>>=))
import Data.List.Extra        (chunksOf, transpose)
import FlexTask.Generic.Parse (
  Parse(..),
  displayInputAnd,
  escaped,
  parseInstanceMultiChoice,
  parseWithFallback,
  parseWithOrReport,
  reportWithFieldNumber
  )
import LogicTasks.Formula      (TruthValue)
import Formula.Parsing.Delayed (
  complainAboutMissingParenthesesIfNotFailingOn,
  )
import ParsingHelpers          (fully)
import Trees.Parsing           ()
import Trees.Types             (PropFormula(..))

import qualified Formula.Parsing as FP

import Global
import TaskSettings


instance Parse TruthValue where
  formParser = escaped FP.parser


instance Parse [Namen] where
  formParser = parseInstanceMultiChoice


makeTable :: [Maybe (PropFormula Char)] -> [Maybe TruthValue] -> Table
makeTable headers values = Table $ zip allHeaders formattedTruthValues
  where
    allHeaders = map (Just . Atomic) "ABC" ++ headers
    formattedTruthValues = transpose $ chunksOf totalColumns values


parseSubmission :: (Monad m, OutputCapable (ReportT o m)) => String -> LangM' (ReportT o m) Submission
parseSubmission input =
  parseWithOrReport formParser reportWithFieldNumber input $>>= \(fs, f, headers, columns, names) ->
    traverse parseIt fs $>>= \parsedFs ->
      parseIt f $>>= \parsedF ->
        traverse (traverse parseIt) headers $>>= \parsedHeaders ->
          pure (parsedFs, parsedF, makeTable parsedHeaders columns, names)
  where
    parseIt =
      parseWithFallback
        (fully FP.parser)
        (displayInputAnd complainAboutMissingParenthesesIfNotFailingOn)
        (fully FP.formulaSymbolParser)

