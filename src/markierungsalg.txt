module Global where


import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..))
import FlexTask.Generic.Form

newtype CharAnswer = CharAnswer {unCharAnswer :: [Char]} deriving (Eq, Show)

type Submission = ([      Maybe CharAnswer], SingleChoiceSelection, Maybe [(Char,TruthValue)])
type Solution   = ([(Int, [Char])         ], Bool,                        [(Char,Bool)      ])

type TaskData = (SynTree BinOp Char, Solution)

=============================================


module TaskSettings where


import Data.List ((\\))

import Control.OutputCapable.Blocks
import Horn
import Trees.Types (SynTree(..), BinOp(..))


atomics :: [Char]
atomics = getAllAtomics spirit

steps :: Int
steps =  length atomics + extra

{- - - configuration constants - - -}

-- v1, v2, custom list of clauses
spirit :: [SynTree BinOp Char]
spirit = v1

extra :: Int
extra = 0

showSolution :: Bool
showSolution = True

{- - - - - - - - - - - - - - - - - -}

validateSettings :: OutputCapable m => LangM m
validateSettings
    | extra > length atomics = refuse $ indent $ text $
        "Es können nur so viele extra Klauseln hinzugefügt werden, " ++
            "wie in spirit bereits enthalten sind."
    | (atomics \\ ['A' .. 'L']) /= [] = refuse $ indent $ text $
        "Es dürfen nur Buchstaben aus dem Intervall ['A' .. 'L'], " ++
            "für die atomaren Aussagen verwendet werden."
    | otherwise = pure ()

=============================================


{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskData (getTask) where


import Data.String.Interpolate (i)
import Data.String             (fromString)
import Data.Text               (Text, pack)
import Test.QuickCheck.Gen
import Yesod                   (RenderMessage(..), SomeMessage(..), fieldSettingsLabel)

import FlexTask.FormUtil       (getFormData, ($$>))
import FlexTask.Generic.Form
import FlexTask.Types          (HtmlDict)
import FlexTask.YesodConfig    (Rendered, Widget)
import Horn                    (makeHornFormula, startAlgorithm)

import Global
import TaskSettings


data Label = Step Int | Output | Model | Satisfiable | Unsatisfiable

instance RenderMessage a Label where
    renderMessage _ ("de":_) (Step n)      = pack ("Schritt " ++ show n ++ ":")
    renderMessage _ ("de":_) Output        = "Ausgabe:"
    renderMessage _ ("de":_) Model         = "Modell:"
    renderMessage _ ("de":_) Satisfiable   = "erfüllbar"
    renderMessage _ ("de":_) Unsatisfiable = "unerfüllbar"
    renderMessage _ _        (Step n)      = pack ("Step " ++ show n ++ ":")
    renderMessage _ _        Output        = "Output:"
    renderMessage _ _        Model         = "Model:"
    renderMessage _ _        Satisfiable   = "satisfiable"
    renderMessage _ _        Unsatisfiable = "unsatisfiable"


getTask :: Gen (TaskData, String, IO ([Text],HtmlDict))
getTask = do
    formula <- makeHornFormula spirit extra
    let solution = startAlgorithm formula
    pure ((formula,solution), checkers, getFormData form)


form :: Rendered Widget
form = formify (Nothing :: Maybe [Maybe String]) fieldNames $$>
    formify (Nothing :: Maybe (SingleChoiceSelection, Maybe String))
    [[ dropdown (fieldSettingsLabel Output)
        [ fromString "---"
        , SomeMessage Satisfiable
        , SomeMessage Unsatisfiable
        ]
    , single (fieldSettingsLabel Model)
    ]]

  where
    fieldNames = [[list Vertical (map (fieldSettingsLabel . Step) [1..steps])]]


checkers :: String
checkers = [i|


{-\# language ApplicativeDo \#-}
{-\# LANGUAGE LambdaCase \#-}

module Check (checkSyntax, checkSemantics) where


import Data.Foldable (traverse_)
import Data.List (intersperse, intercalate, sort, (\\\\))
import Data.Maybe (catMaybes, fromJust, isJust, isNothing)
import Data.Ratio ((%))
import Data.Tuple.Extra (second)

import Control.Monad (when)
import Control.OutputCapable.Blocks
import FlexTask.Generic.Form (getAnswer)
import Horn
import LogicTasks.Formula (TruthValue(..))
import Trees.Print (simplestDisplay)

import qualified Data.List.Extra as List (replace)

import Global


checkSyntax :: OutputCapable m => FilePath -> TaskData -> Submission -> LangM m
checkSyntax _ (formula,_) (steps, output, model) = do
    checking (all isNothing steps && isNothing model) $ do
        german "Es dürfen nicht alle Texteingabefelder leer sein."
        english "Not all text input fields may be left blank."
    checking (any isJust (dropWhile isJust steps)) $ do
        german "Es dürfen keine Schritte übersprungen werden."
        english "Steps cannot be skipped."
    checking (getAnswer output == Just 1) $ do
        german "Es muss eine Ausgabe für den Algorithmus ausgewählt werden."
        english "An output option needs to be selected."
    checking (getAnswer output == Just 3 && isJust model) $ do
        german $ "Widerspruch gefunden: " ++
            "Die Formel sei unerfüllbar, dennoch wurde eine erfüllende Belegung (Modell) angegeben."
        english $ "Contradiction found: " ++
            "The formula is said to be unsatisfiable, yet a satisfying assignment (model) was provided."

    paragraph $ translate $ do
        german "Die Einsendung wird interpretiert als:"
        english "The submission is interpreted as:"
    paragraph $ indent $ latex $ foldl (\\acc (i,c) -> List.replace [c] ("\\\\underline{" ++ [c] ++ "^" ++ show i ++ "}") acc)
        (simplestDisplay formula) $ concatMap (\\(i,s) -> map (i,) s) stepsSubmitted
    paragraph $ traverse_ (\\(i,c) -> indent $ translate $ do
        german $  "Schritt " ++ show i ++ ": " ++ intersperse ',' c ++ "\\n"
        english $ "Step " ++ show i ++ ": " ++ intersperse ',' c) ++ "\\n" stepsSubmitted

    paragraph $ do
        indent $ translate $ do
            german (case getAnswer output of
                Just 3 -> "\\"unerfüllbar\\""
                Just 2 -> "\\"erfüllbar\\", mit"
                _      -> "")
            english (case getAnswer output of
                Just 3 -> "\\"unsatisfiable\\""
                Just 2 -> "\\"satisfiable\\", mit"
                _      -> "")
        case model of
            Nothing -> pure ()
            Just m  -> indent $ latex $ intercalate ",\\\\ " $
                map (\\(c,w) -> "\\\\alpha(" ++ [c] ++  ")=" ++ show (fromEnum $ truth w)) m
        pure ()

    checking ((sort (concat marked) \\\\ allAtomics) /= []) $ do
        german $ "Markiert werden können nur jene atomare Aussagen, " ++
            "welche in der Formel vorkommen und nicht bereits markiert worden sind."
        english "Only those atomic statements that occur in the formula and are not yet marked can be marked."
    checking (any ((> 1) . length) (drop 1 marked)) $ do
        german "Mit Ausnahme von Schritt 1, darf immer nur eine Aussage pro Schritt markiert werden."
        english "Apart from step 1, exactly one statement may be marked in each step."
    checking ((\\case
        (Just step : _) -> getFacts clauses /= unCharAnswer step
        _               -> False) steps) $ do
            german "Im ersten Schritt müssen alle Fakten markiert werden."
            english "In the first step, all facts must be marked."
    checking (isJust model && sort (map fst $ fromJust model) /= allAtomics) $ do
        german "Im Modell muss jede atomare Teilformel genau einmal vorkommen."
        english "The model must contain each atomic subformula exactly once."
    pure ()
  where
    checking condition msg = when condition $ refuse $ indent $ translate msg
    clauses = getClauses formula
    allAtomics = sort $ getAllAtomics clauses
    marked = map unCharAnswer $ catMaybes steps
    stepsSubmitted = zip [1..] (map unCharAnswer (catMaybes steps))


checkSemantics :: OutputCapable m => FilePath -> TaskData -> Submission -> Rated m
checkSemantics _ (formula, (correctSteps, correctOutput, correctModel)) (steps, output, model) = do
    let stepsCorrect = correctSteps == stepsSubmitted
    yesNo stepsCorrect $ translate $ do
        german "Schritte richtig?"
        english "Steps correct?"
    let outputCorrect = Just (if correctOutput then 2 else 3) == getAnswer output
    yesNo outputCorrect $ translate $ do
        german "Ausgabe richtig?"
        english "Output correct?"
    let modelCorrect = sort correctModel == sort (maybe [] (map (second truth)) model)
    yesNo modelCorrect $ translate $ do
        german "Modell richtig?"
        english "Model correct?"
    let points = (if stepsCorrect then 0.4 else 0.0) +
                 (if outputCorrect then 0.2 else 0.0) +
                 (if modelCorrect then 0.4 else 0.0)
    res <- printSolutionAndAssertMinimum (MinimumThreshold (1 % 4)) IndefiniteArticle maybeAnswer points
    pure res
  where
    maybeAnswer = if #{showSolution} then (Just "Lösung steht hier") else Nothing
    stepsSubmitted = zip [1..] (map unCharAnswer (catMaybes steps))
|]

=============================================

{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks

import Trees.Print (simplestDisplay)

import Global


description :: OutputCapable m => FilePath -> TaskData -> LangM m
description _ (formula,_) = do
    paragraph $ translate $ do
        german "Gegeben ist eine Hornformel, welche sich bereits in Implikationsschreibweise befindet:"
        english "A Horn formula is given, which is already in implicational form."
    indent $ latex (simplestDisplay formula)
    paragraph $ translate $ do
        german "Wenden Sie den Markierungsalgorithmus aus der Vorlesung auf die Formel an."
        english "Apply the marking algorithm from the lecture to the formula."
    indent $ translate $ do
        german "Vervollständigen Sie das Protokoll."
        english "Complete the protocol."
    paragraph $ translate $ do
        english "Use the following notations:"
        german "Beachten Sie die folgenden Schreibweisen:"
    indent $ translate $ do
        english "Example of a listing of the statements marked in a step:"
        german "Beispiel für die Angabe der in einem Schritt markierten Aussagen:"
    code "A, B"
    indent $ translate $ do
        english "Example of a Model:"
        german "Beispiel für die Angabe eines Modells:"
    code "A:1, B:0"
    paragraph $ translate $ do
        german "Eingabefelder, die für die Lösung nicht erforderlich sind, können freigelassen werden."
        english "You can leave input fields blank if they’re not needed for the solution."
    pure ()


=============================================


module Parse (parseSubmission) where


import Text.Parsec

import Control.OutputCapable.Blocks (
  LangM',
  ReportT,
  OutputCapable,
  )
import FlexTask.Generic.Parse  (
  Parse(..),
  escaped,
  formParser,
  parseWithOrReport,
  reportWithFieldNumber
  )
import LogicTasks.Formula (TruthValue(..))

import qualified LogicTasks.Parsing as P


import Global


instance Parse CharAnswer where
  formParser = escaped $ do CharAnswer
     <$>    (do spaces
                c <- satisfy (`elem` ['A' .. 'Z'])
                spaces
                pure c) `sepBy` char ','

instance Parse [(Char,TruthValue)] where
  formParser = escaped $ do
    result <- tupleParser `sepBy` char ','
    pure result
    where
      tupleParser = do
        spaces
        c <- satisfy (`elem` ['A'..'Z'])
        spaces
        _ <- char ':'
        spaces
        t <- P.parser
        spaces
        pure (c,t)


parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber
