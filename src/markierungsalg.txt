module Global where


import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..))
import FlexTask.Generic.Form

newtype CharAnswer = CharAnswer {unCharAnswer :: [Char]} deriving (Eq, Show)

type Submission = ([      Maybe CharAnswer], SingleChoiceSelection, Maybe [(Char,TruthValue)])
type Solution   = ([(Int, [Char])         ], Bool,                        [(Char,Bool)])

type TaskData = (SynTree BinOp Char, Solution)

=============================================


module TaskSettings where


import Control.OutputCapable.Blocks (LangM, OutputCapable)
import Horn
import Trees.Types (SynTree(..), BinOp(..))


-- v1, v2, custom list of clauses
spirit :: [SynTree BinOp Char]
spirit = v1

extra :: Int
extra = 0

steps :: Int
steps = 3

validateSettings :: OutputCapable m => LangM m
validateSettings = pure ()


=============================================


{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskData (getTask) where


import Data.String.Interpolate (i)
import Data.String             (fromString)
import Data.Text               (Text, pack)
import Test.QuickCheck.Gen
import Yesod                   (RenderMessage(..), SomeMessage(..), fieldSettingsLabel)

import FlexTask.FormUtil       (getFormData, ($$>))
import FlexTask.Generic.Form
import FlexTask.Types          (HtmlDict)
import FlexTask.YesodConfig    (Rendered, Widget)
import Horn                    (makeHornFormula, startAlgorithm)

import Global
import TaskSettings


data Label = Step Int | Output | Model | Satisfiable | Unsatisfiable

instance RenderMessage a Label where
  renderMessage _ ("de":_) (Step n)      = pack ("Schritt " ++ show n ++ ":")
  renderMessage _ ("de":_) Output        = "Ausgabe:"
  renderMessage _ ("de":_) Model         = "Modell:"
  renderMessage _ ("de":_) Satisfiable   = "erfüllbar"
  renderMessage _ ("de":_) Unsatisfiable = "unerfüllbar"
  renderMessage _ _        (Step n)      = pack ("Step " ++ show n ++ ":")
  renderMessage _ _        Output        = "Output:"
  renderMessage _ _        Model         = "Model:"
  renderMessage _ _        Satisfiable   = "satisfiable"
  renderMessage _ _        Unsatisfiable = "unsatisfiable"


getTask :: Gen (TaskData, String, IO ([Text],HtmlDict))
getTask = do
    formula <- makeHornFormula spirit extra
    let solution = startAlgorithm formula
    pure ((formula,solution), checkers, getFormData form)


form :: Rendered Widget
form = formify (Nothing :: Maybe [Maybe String]) fieldNames $$>
    formify (Nothing :: Maybe (SingleChoiceSelection, Maybe String))
    [[ dropdown (fieldSettingsLabel Output)
        [ fromString "---"
        , SomeMessage Satisfiable
        , SomeMessage Unsatisfiable
        ]
    , single (fieldSettingsLabel Model)
    ]]

  where
    fieldNames = [[list Vertical (map (fieldSettingsLabel . Step) [1..steps])]]


checkers :: String
checkers = [i|


{-\# language ApplicativeDo \#-}

module Check (checkSyntax, checkSemantics) where


import Data.List (sort)
import Data.Maybe (isJust, catMaybes, fromMaybe)
import Data.Tuple.Extra (second)

import Control.Monad (when)
import Control.OutputCapable.Blocks
import FlexTask.Generic.Form (getAnswer)
import Horn
import LogicTasks.Formula (TruthValue(..))

import Global

checkSyntax :: OutputCapable m => FilePath -> TaskData -> Submission -> LangM m
checkSyntax _ _ (steps, output, model) = do
   yesNo (any isJust steps) $ translate $ do
        german $ show steps
        english "Steps correct?"


checkSemantics :: OutputCapable m => FilePath -> TaskData -> Submission -> Rated m
checkSemantics _ (formula, (correctSteps, correctOutput, correctModel)) (steps, output, model) = do
    yesNo (correctSteps == zip [1..] (map unCharAnswer (catMaybes steps))) $ translate $ do
        german "Schritte richtig?"
        english "Steps correct?"
    yesNo (Just (if correctOutput then 2 else 3) == getAnswer output) $ translate $ do
        german "Ausgabe richtig?"
        english "Output correct?"
    yesNo (sort correctModel == sort (map (second truth) (fromMaybe [] model))) $ translate $ do
        german "Modell richtig?"
        english "Model correct?"
    pure 1
|]

=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks

import Trees.Print (simplestDisplay)

import Global


description :: OutputCapable m => FilePath -> TaskData -> LangM m
description _ (formula,_) = do
  paragraph $ translate $ do
    german "Gegeben ist eine Hornformel, welche sich bereits in Implikationsschreibweise befindet:"
    english "A Horn formula is given, which is already in implicational form."
  indent $ latex (simplestDisplay formula)
  paragraph $ translate $ do
    german "Wenden Sie den Markierungsalgorithmus aus der Vorlesung auf die Formel an."
    english "Apply the marking algorithm from the lecture to the formula."
  indent $ translate $ do
    german "Vervollständigen Sie das Protokoll."
    english "Complete the protocol."
  paragraph $ translate $ do
      english "Use the following notations:"
      german "Beachten Sie die folgenden Schreibweisen:"
  indent $ translate $ do
      english "Example of a listing of the statements marked in a step:"
      german "Beispiel für die Angabe der in einem Schritt markierten Aussagen:"
  code "A, B"
  indent $ translate $ do
      english "Example of a Model:"
      german "Beispiel für die Angabe eines Modells:"
  code "A:1, B:0"
  paragraph $ translate $ do
    german "Eingabefelder, die für die Lösung nicht erforderlich sind, können freigelassen werden."
    english "You can leave input fields blank if they’re not needed for the solution."
  pure ()


=============================================


module Parse (parseSubmission) where


import Data.Functor (($>))
import Text.Parsec

import Control.OutputCapable.Blocks (
  LangM',
  ReportT,
  OutputCapable,
  )
import FlexTask.Generic.Parse  (
  Parse(..),
  escaped,
  formParser,
  parseWithOrReport,
  reportWithFieldNumber
  )
import LogicTasks.Formula (TruthValue(..))

import qualified LogicTasks.Parsing as P


import Global


instance Parse CharAnswer where
  formParser = escaped $ do CharAnswer
     <$>    (do spaces
                c <- satisfy (`elem` ['A' .. 'Z'])
                spaces
                pure c) `sepBy` char ','

instance Parse [(Char,TruthValue)] where
  formParser = escaped $ do
    result <- tupleParser `sepBy` char ','
    pure result
    where
      tupleParser = do
        spaces
        c <- satisfy (`elem` ['A'..'Z'])
        spaces
        _ <- char ':'
        spaces
        t <- P.parser
        spaces
        pure (c,t)


parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber
