module Global where


import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..))
import FlexTask.Generic.Form

newtype CharAnswer = CharAnswer {unCharAnswer :: [Char]} deriving (Eq, Show)

type Submission = ([      Maybe CharAnswer], SingleChoiceSelection, Maybe [(Char,TruthValue)])
type Solution   = ([(Int, [Char])         ], Bool,                        [(Char,Bool)      ])

type TaskData = (SynTree BinOp Char, Solution)

=============================================


module TaskSettings where


import Control.OutputCapable.Blocks (LangM, OutputCapable)
import Horn
import Trees.Types (SynTree(..), BinOp(..))


-- v1, v2, custom list of clauses
spirit :: [SynTree BinOp Char]
spirit = v1

extra :: Int
extra = 0

steps :: Int
steps = 3

validateSettings :: OutputCapable m => LangM m
validateSettings = pure ()


=============================================


{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskData (getTask) where


import Data.String.Interpolate (i)
import Data.String             (fromString)
import Data.Text               (Text, pack)
import Test.QuickCheck.Gen
import Yesod                   (RenderMessage(..), SomeMessage(..), fieldSettingsLabel)

import FlexTask.FormUtil       (getFormData, ($$>))
import FlexTask.Generic.Form
import FlexTask.Types          (HtmlDict)
import FlexTask.YesodConfig    (Rendered, Widget)
import Horn                    (makeHornFormula, startAlgorithm)

import Global
import TaskSettings


data Label = Step Int | Output | Model | Satisfiable | Unsatisfiable

instance RenderMessage a Label where
  renderMessage _ ("de":_) (Step n)      = pack ("Schritt " ++ show n ++ ":")
  renderMessage _ ("de":_) Output        = "Ausgabe:"
  renderMessage _ ("de":_) Model         = "Modell:"
  renderMessage _ ("de":_) Satisfiable   = "erfüllbar"
  renderMessage _ ("de":_) Unsatisfiable = "unerfüllbar"
  renderMessage _ _        (Step n)      = pack ("Step " ++ show n ++ ":")
  renderMessage _ _        Output        = "Output:"
  renderMessage _ _        Model         = "Model:"
  renderMessage _ _        Satisfiable   = "satisfiable"
  renderMessage _ _        Unsatisfiable = "unsatisfiable"


getTask :: Gen (TaskData, String, IO ([Text],HtmlDict))
getTask = do
    formula <- makeHornFormula spirit extra
    let solution = startAlgorithm formula
    pure ((formula,solution), checkers, getFormData form)


form :: Rendered Widget
form = formify (Nothing :: Maybe [Maybe String]) fieldNames $$>
    formify (Nothing :: Maybe (SingleChoiceSelection, Maybe String))
    [[ dropdown (fieldSettingsLabel Output)
        [ fromString "---"
        , SomeMessage Satisfiable
        , SomeMessage Unsatisfiable
        ]
    , single (fieldSettingsLabel Model)
    ]]

  where
    fieldNames = [[list Vertical (map (fieldSettingsLabel . Step) [1..steps])]]


checkers :: String
checkers = [i|


{-\# language ApplicativeDo \#-}
{-\# LANGUAGE LambdaCase \#-}

module Check (checkSyntax, checkSemantics) where


import Data.List (sort, (\\\\))
import Data.Maybe (catMaybes, fromJust, isJust, isNothing)
import Data.Tuple.Extra (second)

import Control.Monad (when)
import Control.OutputCapable.Blocks
import FlexTask.Generic.Form (getAnswer)
import Horn
import LogicTasks.Formula (TruthValue(..))

import Global


checkSyntax :: OutputCapable m => FilePath -> TaskData -> Submission -> LangM m
checkSyntax _ (formula,_) (steps, output, model) = do
    checking (getAnswer output == Just 1) $ do
        german "Es muss eine Ausgabe für den Algorithmus ausgewählt werden."
        english "An output option needs to be selected."
    checking (all isNothing steps && isNothing model) $ do
            german "Es dürfen nicht alle Texteingabefelder leer sein."
            english "Not all text input fields may be left blank."
    checking (any isJust (dropWhile isJust steps)) $ do
            german "Es dürfen keine Schritte übersprungen werden."
            english "Steps cannot be skipped."
    checking (getAnswer output == Just 3 && isJust model) $ do
            german $ "Widerspruch gefunden: " ++
                "Die Formel sei unerfüllbar, dennoch wurde eine erfüllende Belegung (Modell) angegeben."
            english $ "Contradiction found: " ++
                "The formula is said to be unsatisfiable, yet a satisfying assignment (model) was provided."
    checking (isJust model && sort (map fst $ fromJust model) /= allAtomics) $ do
            german "Im Modell muss jede atomare Teilformel genau einmal vorkommen."
            english "The model must contain each atomic subformula exactly once."
    checking ((\\case
        (Just step : _) -> getFacts clauses /= unCharAnswer step
        _               -> False) steps) $ do
            german "Im ersten Schritt müssen alle Fakten markiert werden."
            english "In the first step, all facts must be marked."
    checking (any ((> 1) . length) (drop 1 marked)) $ do
            german "Mit Ausnahme von Schritt 1, darf immer nur eine Aussage pro Schritt markiert werden."
            english "Apart from step 1, exactly one statement may be marked in each step."
    checking ((sort (concat marked) \\\\ allAtomics) /= []) $ do
        german $ "Markiert werden können nur jene atomare Aussagen, " ++
            "welche in der Formel vorkommen und nicht bereits markiert worden sind."
        english "Only those atomic statements that occur in the formula and are not yet marked can be marked."
    pure ()
  where
    checking condition msg = when condition $ refuse $ indent $ translate msg
    clauses = getClauses formula
    allAtomics = sort $ getAllAtomics clauses
    marked = map unCharAnswer $ catMaybes steps

checkSemantics :: OutputCapable m => FilePath -> TaskData -> Submission -> Rated m
checkSemantics _ (_, (correctSteps, correctOutput, correctModel)) (steps, output, model) = do
    yesNo (correctSteps == zip [1..] (map unCharAnswer (catMaybes steps))) $ translate $ do
        german "Schritte richtig?"
        english "Steps correct?"
    yesNo (Just (if correctOutput then 2 else 3) == getAnswer output) $ translate $ do
        german "Ausgabe richtig?"
        english "Output correct?"
    yesNo (sort correctModel == sort (maybe [] (map (second truth)) model)) $ translate $ do
        german "Modell richtig?"
        english "Model correct?"
    pure 1
|]

=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks

import Trees.Print (simplestDisplay)

import Global


description :: OutputCapable m => FilePath -> TaskData -> LangM m
description _ (formula,_) = do
  paragraph $ translate $ do
    german "Gegeben ist eine Hornformel, welche sich bereits in Implikationsschreibweise befindet:"
    english "A Horn formula is given, which is already in implicational form."
  indent $ latex (simplestDisplay formula)
  paragraph $ translate $ do
    german "Wenden Sie den Markierungsalgorithmus aus der Vorlesung auf die Formel an."
    english "Apply the marking algorithm from the lecture to the formula."
  indent $ translate $ do
    german "Vervollständigen Sie das Protokoll."
    english "Complete the protocol."
  paragraph $ translate $ do
      english "Use the following notations:"
      german "Beachten Sie die folgenden Schreibweisen:"
  indent $ translate $ do
      english "Example of a listing of the statements marked in a step:"
      german "Beispiel für die Angabe der in einem Schritt markierten Aussagen:"
  code "A, B"
  indent $ translate $ do
      english "Example of a Model:"
      german "Beispiel für die Angabe eines Modells:"
  code "A:1, B:0"
  paragraph $ translate $ do
    german "Eingabefelder, die für die Lösung nicht erforderlich sind, können freigelassen werden."
    english "You can leave input fields blank if they’re not needed for the solution."
  pure ()


=============================================


module Parse (parseSubmission) where


import Text.Parsec

import Control.OutputCapable.Blocks (
  LangM',
  ReportT,
  OutputCapable,
  )
import FlexTask.Generic.Parse  (
  Parse(..),
  escaped,
  formParser,
  parseWithOrReport,
  reportWithFieldNumber
  )
import LogicTasks.Formula (TruthValue(..))

import qualified LogicTasks.Parsing as P


import Global


instance Parse CharAnswer where
  formParser = escaped $ do CharAnswer
     <$>    (do spaces
                c <- satisfy (`elem` ['A' .. 'Z'])
                spaces
                pure c) `sepBy` char ','

instance Parse [(Char,TruthValue)] where
  formParser = escaped $ do
    result <- tupleParser `sepBy` char ','
    pure result
    where
      tupleParser = do
        spaces
        c <- satisfy (`elem` ['A'..'Z'])
        spaces
        _ <- char ':'
        spaces
        t <- P.parser
        spaces
        pure (c,t)


parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber
