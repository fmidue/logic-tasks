module Global where


import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..))
import FlexTask.Generic.Form

newtype CharAnswer = CharAnswer {unCharAnswer :: [Char]}

type Submission = ([CharAnswer], SingleChoiceSelection, [(Char,TruthValue)])
type TaskData = SynTree BinOp Char


=============================================


module TaskSettings where


import Control.OutputCapable.Blocks (LangM, OutputCapable)
import Horn
import Trees.Types (SynTree(..), BinOp(..))


-- v1, v2, custom list of clauses
spirit :: [SynTree BinOp Char]
spirit = v1

extra :: Int
extra = 0

steps :: Int
steps = 3

validateSettings :: OutputCapable m => LangM m
validateSettings = pure ()


=============================================


{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskData (getTask) where


import Data.String.Interpolate (i)
import Data.String             (fromString)
import Data.Text               (Text, pack)
import Test.QuickCheck.Gen
import Yesod                   (RenderMessage(..), SomeMessage(..), fieldSettingsLabel)

import FlexTask.FormUtil       (getFormData, ($$>))
import FlexTask.Generic.Form
import FlexTask.Types          (HtmlDict)
import FlexTask.YesodConfig    (Rendered, Widget)
import Horn                    (makeHornFormula)

import Global
import TaskSettings


data Label = Step Int | Output | Model | Satisfiable | Unsatisfiable

instance RenderMessage a Label where
  renderMessage _ ("de":_) (Step n)      = pack ("Schritt " ++ show n ++ ":")
  renderMessage _ ("de":_) Output        = "Ausgabe:"
  renderMessage _ ("de":_) Model         = "Modell:"
  renderMessage _ ("de":_) Satisfiable   = "erfüllbar"
  renderMessage _ ("de":_) Unsatisfiable = "unerfüllbar"
  renderMessage _ _        (Step n)      = pack ("Step " ++ show n ++ ":")
  renderMessage _ _        Output        = "Output:"
  renderMessage _ _        Model         = "Model:"
  renderMessage _ _        Satisfiable   = "satisfiable"
  renderMessage _ _        Unsatisfiable = "unsatisfiable"


getTask :: Gen (TaskData, String, IO ([Text],HtmlDict))
getTask = do
    formula <- makeHornFormula spirit extra
    pure (formula, checkers, getFormData form)


form :: Rendered Widget
form = formify (Nothing :: Maybe [Maybe String]) fieldNames $$>
    formify (Nothing :: Maybe (SingleChoiceSelection, Maybe String))
    [[ dropdown (fieldSettingsLabel Output)
        [ fromString "---"
        , SomeMessage Satisfiable
        , SomeMessage Unsatisfiable
        ]
    , single (fieldSettingsLabel Model)
    ]]

  where
    fieldNames = [[list Vertical (map (fieldSettingsLabel . Step) [1..steps])]]


checkers :: String
checkers = [i|


{-\# language ApplicativeDo \#-}

module Check (checkSyntax, checkSemantics) where

import Data.List (sort)
import Data.Tuple.Extra (second)

import Control.OutputCapable.Blocks
import FlexTask.Generic.Form (getAnswer)
import Horn
import LogicTasks.Formula (TruthValue(..))

import Global


checkSyntax :: OutputCapable m => FilePath -> TaskData -> Submission -> LangM m
checkSyntax _ _ _  = pure ()


checkSemantics :: OutputCapable m => FilePath -> TaskData -> Submission -> Rated m
checkSemantics _ formula (steps, output, model) = do
    let (correctSteps, correctOutput, correctModel) = startAlgorithm formula
    yesNo (correctSteps == zip [1..] (filter (/= "") (map unCharAnswer steps))) $ translate $ do
        german "Schritte richtig?"
        english "Steps correct?"
    yesNo (Just (if correctOutput then 2 else 3) == getAnswer output) $ translate $ do
        german "Ausgabe richtig?"
        english "Output correct?"
    yesNo (sort correctModel == sort (map (second truth) model)) $ translate $ do
        german "Modell richtig?"
        english "Model correct?"
    pure 1
|]

=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks

import Trees.Print (simplestDisplay)

import Global


description :: OutputCapable m => FilePath -> TaskData -> LangM m
description _ formula = do
  paragraph $ translate $ do
    german "Gegeben ist eine Hornformel, welche sich bereits in Implikationsschreibweise befindet:"
    english "A Horn formula is given, which is already in implicational form."
  indent $ latex (simplestDisplay formula)
  paragraph $ translate $ do
    german "Wenden Sie den Markierungsalgorithmus aus der Vorlesung auf die Formel an."
    english "Apply the marking algorithm from the lecture to the formula."
  indent $ translate $ do
    german "Vervollständigen Sie das Protokoll."
    english "Complete the protocol."
  paragraph $ translate $ do
      english "Use the following notations:"
      german "Beachten Sie die folgenden Schreibweisen:"
  indent $ translate $ do
      english "Example of a listing of the statements marked in a step:"
      german "Beispiel für die Angabe der in einem Schritt markierten Aussagen:"
  code "A, B"
  indent $ translate $ do
      english "Example of a Model:"
      german "Beispiel für die Angabe eines Modells:"
  code "A:1, B:0"
  paragraph $ translate $ do
    german "Eingabefelder, die für die Lösung nicht erforderlich sind, können freigelassen werden."
    english "You can leave input fields blank if they’re not needed for the solution."
  pure ()


=============================================


module Parse (parseSubmission) where


import Control.OutputCapable.Blocks (
  LangM',
  ReportT,
  OutputCapable,
  )
import FlexTask.Generic.Parse  (
  Parse(..),
  escaped,
  formParser,
  parseWithOrReport,
  reportWithFieldNumber
  )

import Global
import Text.Parsec
import qualified LogicTasks.Parsing as P
import LogicTasks.Formula (TruthValue(..))
import Data.Functor (($>))


instance Parse CharAnswer where
  formParser = escaped $ do CharAnswer
     <$>
       (try (string "None" $> "")
          <|>
            (do spaces
                c <- satisfy (`elem` ['A' .. 'Z'])
                spaces
                pure c)
              `sepBy` char ',')

instance Parse [(Char,TruthValue)] where
  formParser = escaped $ do
    result <- try (string "None" $> []) <|> tupleParser `sepBy` char ','
    pure result
    where
      tupleParser = do
        spaces
        c <- satisfy (`elem` ['A'..'Z'])
        spaces
        _ <- char ':'
        spaces
        t <- P.parser
        spaces
        pure (c,t)


parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber
