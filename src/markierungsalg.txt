module Global where


import LogicTasks.Formula (TruthValue(..))
import Trees.Types (SynTree(..), BinOp(..))
import FlexTask.Generic.Form

newtype CharAnswer = CharAnswer { unCharAnswer :: [Char]}

type Submission = ([CharAnswer], SingleChoiceSelection, [(Char,TruthValue)])
type TaskData = SynTree BinOp Char


=============================================


module TaskSettings where


import Control.OutputCapable.Blocks (LangM, OutputCapable)
import Horn
import Trees.Types (SynTree(..), BinOp(..))


-- v1, v2, custom list of clauses
spirit :: [SynTree BinOp Char]
spirit = v1

extra :: Int
extra = 0

steps :: Int
steps = 5

validateSettings :: OutputCapable m => LangM m
validateSettings = pure ()


=============================================


{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskData (getTask) where


import Data.String.Interpolate (i)
import Data.String             (fromString)
import Data.Text               (Text, pack)
import Test.QuickCheck.Gen
import Yesod                   (RenderMessage(..), SomeMessage(..), fieldSettingsLabel)

import FlexTask.FormUtil       (getFormData, ($$>))
import FlexTask.Generic.Form
import FlexTask.Types          (HtmlDict)
import FlexTask.YesodConfig    (Rendered, Widget)
import Horn

import Global
import TaskSettings


data Label = Step Int | Output | Model | Satisfiable | Unsatisfiable

instance RenderMessage a Label where
  renderMessage _ ("de":_) (Step n)      = pack ("Schritt " ++ show n ++ ":")
  renderMessage _ ("de":_) Output        = "Ausgabe:"
  renderMessage _ ("de":_) Model         = "Modell:"
  renderMessage _ ("de":_) Satisfiable   = "erfüllbar"
  renderMessage _ ("de":_) Unsatisfiable = "unerfüllbar"
  renderMessage _ _        (Step n)      = pack ("Step " ++ show n ++ ":")
  renderMessage _ _        Output        = "Output:"
  renderMessage _ _        Model         = "Model:"
  renderMessage _ _        Satisfiable   = "satisfiable"
  renderMessage _ _        Unsatisfiable = "unsatisfiable"


getTask :: Gen (TaskData, String, IO ([Text],HtmlDict))
getTask = do
    formula <- makeHornFormula spirit extra
    pure (formula, checkers, getFormData form)


form :: Rendered Widget
form = formify (Nothing :: Maybe [String]) fieldNames $$>
    formify (Nothing :: Maybe (SingleChoiceSelection, String))
    [[ dropdown (fieldSettingsLabel Output)
        [ fromString "---"
        , SomeMessage Satisfiable
        , SomeMessage Unsatisfiable
        ]
    , single (fieldSettingsLabel Model)
    ]]

  where
    fieldNames = [[list Vertical (map (fieldSettingsLabel . Step) [1..steps])]]


checkers :: String
checkers = [i|


{-\# language ApplicativeDo \#-}

module Check (checkSyntax, checkSemantics) where


import Control.OutputCapable.Blocks

import Global


checkSyntax :: OutputCapable m => FilePath -> TaskData -> Submission -> LangM m
checkSyntax _ _ _  = pure ()


checkSemantics :: OutputCapable m => FilePath -> TaskData -> Submission -> Rated m
checkSemantics _ _ _ = pure 1

|]


=============================================


{-# Language ApplicativeDo #-}

module Description (description) where


import Control.OutputCapable.Blocks

import Trees.Print (simplestDisplay)

import Global


description :: OutputCapable m => FilePath -> TaskData -> LangM m
description _ formula = do
  paragraph $ translate $ do
    german "Gegeben ist eine Hornformel, welche sich bereits in Implikationsschreibweise befindet:"
    english "A Horn formula is given, which is already in implicational form."
  indent $ latex (simplestDisplay formula)
  paragraph $ translate $ do
    german "Wenden Sie den Markierungsalgorithmus aus der Vorlesung auf die Formel an."
    english "Apply the marking algorithm from the lecture to the formula."
  indent $ translate $ do
    german "Vervollständigen Sie das Protokoll."
    english "Complete the protocol."
  paragraph $ translate $ do
      english "Use the the following notations:"
      german "Beachten Sie die folgenden Schreibweisen:"
  indent $ translate $ do
      english "Example of a listing of the statements marked in a step:"
      german "Beispiel für die Angabe der in einem Schritt markierten Aussagen:"
  code "A, B"
  indent $ translate $ do
      english "Example of a Model:"
      german "Beispiel für die Angabe eines Modells:"
  code "A:1, B:0"
  paragraph $ translate $ do
    german "Hinweis, dass mehr Schrittfelder als nötig da sein könnten."
    english "todo"
  pure ()


=============================================


module Parse (parseSubmission) where


import Control.OutputCapable.Blocks (
  LangM',
  ReportT,
  OutputCapable,
  )
import FlexTask.Generic.Parse  (
  Parse(..),
  escaped,
  formParser,
  parseWithOrReport,
  reportWithFieldNumber
  )

import Global
import Text.Parsec
import qualified LogicTasks.Parsing as P
import LogicTasks.Formula (TruthValue(..))


instance Parse CharAnswer where
  formParser = escaped $  do
    result <- (do spaces
                  c <- satisfy (`elem` ['A'..'Z'])
                  spaces
                  pure c
              ) `sepBy` char ','
    pure $ CharAnswer result

instance Parse [(Char,TruthValue)] where
  formParser = escaped $ do
    result <- tupleParser `sepBy` char ','
    pure result
    where
      tupleParser = do
        spaces
        c <- satisfy (`elem` ['A'..'Z'])
        spaces
        _ <- char ':'
        spaces
        t <- P.parser
        spaces
        pure (c,t)


parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber
